# SLAM  Back-end : Bundle Adjustment
The project implements the back end of the SLAM system including Bundle Adjustment and g2o graph optimization.

- **Projection model and BA cost function**

1.Convert world coordinates to camera coordinates

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{130}&space;\large&space;P'=Rp&plus;t=[X',&space;Y',&space;Z']^T." />
   </div>  

2.Normalized coordinates
   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{130}&space;\large&space;P_c=[u_c,&space;v_c,&space;1]^T=[X'/Z',&space;Y'/Z',&space;1]^T." />
   </div>  

3.Undistorted pixel coordinates (only radial distortion)

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;\begin{cases}&space;u'_c=u_c(1&plus;k_1r_c^2&plus;k_2r_c^4)&space;\\&space;v'_c=v_c(1&plus;k_1r_c^2&plus;k_2r_c^4)&space;\end{cases}" />
   </div>

where <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;r_c^2=u_c^2+v_c^2"/>

4.According to the camera calibration model, calculate the pixel coordinates

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;\begin{cases}&space;u_s=f_x&space;u'_c&plus;c_x&space;\\&space;v_s=f_y&space;v'_c&plus;c_y&space;\end{cases}" />
   </div>

The Cost Function:
   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;\frac{1}{2}\sum_{i=1}^m \sum_{j=1}^n\|e_{ij}\|^2=\frac{1}{2}\sum_{i=1}^m \sum_{j=1}^n\|z_{ij}-h(T_i,p_j)\|^2" />
   </div>

where <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;z_{ij}"/> is the data generated by observing the landmark <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;p_j"/> at the pose <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;T_i"/>.

- **g2o graph optimization**
  
Define all the variables:

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;x=[T_1,...,T_m,p_1,...,p_n]^T" />
   </div>

The objective function becomes:

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;\frac{1}{2}\|f(x&plus;\Delta&space;x)\|^2&space;\approx&space;\frac{1}{2}\sum_{i=1}^m&space;\sum_{j=1}^n\|e_{ij}&plus;F_{ij}\Delta&space;\xi_i&plus;E_{ij}\Delta&space;p_j\|^2" />
   </div>

where <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;F_{ij}" /> represents the partial derivative of the entire cost function w.r.t. pose in the current state; <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;E_{ij}" /> represents the partial derivative of the entire cost function w.r.t. point position in the current state.

Let
   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;x_c=[\xi_1,\xi_2,...,\xi_m]^T&space;\in&space;\mathbb{R}^{6m}" />
   </div>
         <br>
   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;x_p=[p_1,p_2,...,p_n]^T&space;\in&space;\mathbb{R}^{3n}" />
   </div>

then objective function can be simplified to :

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;\frac{1}{2}\|f(x&plus;\Delta&space;x)\|^2=\frac{1}{2}\|e&plus;F\Delta&space;x_c&plus;E\Delta&space;x_p\|^2" />
   </div>


Thus, the Jacobian 

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;J=[F\&space;E]" />
   </div>

No matter Gauss-Newton or Levenberg-Marquardt, the equation is:
   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;H\Delta&space;x=g" />
   </div>
where 
   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;H=J^TJ=&space;\begin{bmatrix}&space;F^TF&space;&&space;F^TE&space;\\&space;E^TF&space;&&space;E^TE&space;\end{bmatrix}." />
   </div>

- **BAL-dataset**

This project uses [BAL](http://grail.cs.washington.edu/projects/bal/) (Bundle Adjustment in large) dataset and g2o with own defined Vertex and Edge to train a BA program and finally draws the optimized point cloud image. 

- **Direct Method Bundle Adjustment**

This project also use g2o to implement the BA and  graph optimizer aiming to minimize the difference of grey level between the projection of any point in any image and its self. Finally, use pangolin to draw the optimized results.

Given 7 images from 0.png to 6.png, and initial pose value <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;T_i" /> corresponding to each image stock in file poses.txt where each line represents a pose,

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;time,&space;t_x,&space;t_y,&space;t_z,&space;q_x,&space;q_y,&space;q_z,&space;q_w" />
   </div>

also given a 3D point set containing N points with initial coordinate <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;p_i=[x,y,z]_i^T" /> and its own fixed grey level <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;I(p)_i" /> for each point. 

Here is the overall objective function is:

   <div align=center>
   <img src="https://latex.codecogs.com/png.latex?\dpi{120}&space;\large&space;\min\sum_{j=1}^7\sum_{i=1}^N\sum_W\|I(p_i)-I_j(\pi(KT_j&space;p_i))\|_2^2" />
   </div>

where K is the camera calibration, <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;\pi" /> is the projection function, W represents the whole 4x4 path from <img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{120}&space;u-2,&space;v-2$&space;to&space;$u&plus;1,&space;v&plus;1" />.

